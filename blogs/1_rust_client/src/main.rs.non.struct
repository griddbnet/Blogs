extern crate rust_client;

use rust_client::get_value;
use rust_client::griddb::ContainerInfo::*;
use rust_client::griddb::StoreFactory::*;
use rust_client::griddb::Type::*;
use rust_client::griddb::Value::*;
use rust_client::gsvec;
use std::env;
use std::io;
use std::process;
use std::{thread, time::Duration};

use std::error::Error;
use serde::Deserialize;

type Record = (String, String, String, 
                i16, i16, i16, i16,
                f32, f32,
                i16, i16, i16,
                f32, f32, f32,
                );

#[derive(Debug, Deserialize)]
#[serde(rename_all = "PascalCase")]
struct Recordz {
    Name: String,
    Mfr: String,
    Type: String,
    Calories: i16,
    Protein: i16,
    Fat: i16,
    Sodium: i16,
    Fiber: f32,
    Carbo: f32,
    Sugars: i16,
    Potass: i16,
    Vitamins: i16,
    Shelf: f32,
    Cups: f32,
    Rating: f32,
}

fn main() {

        // get default factory
        let factory = StoreFactory::get_instance();
        let args: Vec<_> = env::args().collect();
        let properties = vec![
            ("notification_member", args[1].as_str()),
            ("cluster_name", args[2].as_str()),
            ("user", args[3].as_str()),
            ("password", args[4].as_str()),
        ];
        // get gridstore function
        let store = match factory.get_store(properties) {
            Ok(result) => result,
            Err(error) => panic!("Error factory get_store() with error code: {:?}", error),
        };
    
        let colinfo = ContainerInfo::ContainerInfo(
            "cereal",
            vec![
                ("name", Type::String),
                ("mfr", Type::String),
                ("type", Type::String),
                ("calories", Type::Integer),
                ("protein", Type::Integer),
                ("fat", Type::Integer),
                ("sodium", Type::Integer),
                ("fiber", Type::Double),
                ("carbo", Type::Double),
                ("sugar", Type::Integer),
                ("potass", Type::Integer),
                ("vitamins", Type::Integer),
                ("shelf", Type::Double),
                ("cups", Type::Double),
                ("rating", Type::Double),
            ],
            ContainerType::Collection,
            true,
        );
    
        let con = match store.put_container(&colinfo, false) {
            Ok(result) => result,
            Err(error) => panic!("Error store put_container() with error code: {:?}", error),
        };
        con.set_auto_commit(false);
        con.create_index("name", IndexType::Default);

    //     con.put(gsvec!["Wheaties Honey Gold".to_string(), "G".to_string(), "C".to_string(),
    //     110, 2, 1, 200, 1.0, 16.0, 8, 60, 25, 1.0, 0.75, 36.181  ]);

    //     con.commit();

    //         // container get row
    //     let _row3 = match con.get("cereal") {
    //     Ok(result) => result,
    //     Err(error) => panic!("Error container get row with error code: {:?}", error),
    //  };

    //      // container execute query
    // let query = match con.query("select *") {
    //     Ok(result) => result,
    //     Err(error) => panic!("Error container query data with error code: {:?}", error),
    // };
    // let row_set = match query.fetch() {
    //     Ok(result) => result,
    //     Err(error) => panic!("Error query fetch() data with error code: {:?}", error),
    // };
    // while row_set.has_next() {
    //     let row_data = match row_set.next() {
    //         Ok(result) => result,
    //         Err(error) => panic!("Error row set next() row with error code: {:?}", error),
    //     };
    //     let name: String = get_value![row_data[0]];
    //     println!(
    //         "Person: name={0}]",
    //         name
    //     );
    // }

        let mut rdr = csv::Reader::from_reader(io::stdin());
        for result in rdr.deserialize() {
            match result {
                Ok(record) => {
                    let records: Record = record;
                    // let name = &record[0];
                    // let mfr = &record[1];
                    // let typeo = &record[2];
                    // let calories: i16 = record[3].parse().ok();
                    // let protein = record[4].parse().ok();
                    // let fat = record[5].parse().ok();
                    // let sodium = record[6].parse().ok();
                    // let fiber = record[7].parse().ok();
                    // let carbo= record[8].parse().ok();
                    // let sugars= record[9].parse().ok();
                    // let potass = record[10].parse().ok();
                    // let vitamins = record[11].parse().ok();
                    // let shelf = record[12].parse().ok();
                    // let cups = record[13].parse().ok();
                    // let rating = record[14].parse().ok();
                    // let fuck = vec![
                    //     name,
                    //     mfr,
                    //     typeo,
                    //     calories,
                    //     protein,
                    //     fat,
                    //     sodium,
                    //     fiber,
                    //     carbo,
                    //     sugars,
                    //     potass,
                    //     vitamins,
                    //     shelf,
                    //     cups,
                    //     rating,
                    // ];
                    // con.put(gsvec![fuck]);
                    let err = con.put(gsvec![records]);
                    println!("Error: {}", err);
                        thread::sleep(Duration::from_millis(100));
                }
            
            Err(err) => {
                println!("error reading CSV from <stdin>: {}", err);
                process::exit(1);
            }
        
        }
    }
       


}
